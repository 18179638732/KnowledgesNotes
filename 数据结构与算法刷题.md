# 数据结构与算法

## 基础篇

##### 数组和链表

- 左右指针，
  - 两数之和问题：对于一个有序数组，我们用左指针指向它的最前端位置，用右指针指向它的最右端。然后对指向的元素进行相加，如果小于目标元素，我们就将左指针向右移动，否则如果大于目标元素，我们就将右指针向左移动，如果相等，我们就返回
  - 三数之和：先将其排序，然后我们使用三个指针，固定一个指针，从0到1开始，移动另外两个指针，分别指向头和尾巴，然后将对应的三个数相加，过程同上，一遍之后，我们再将固定的指针往后移动一个元素（判断是否相等，相等我们就跳过）。（在这个过程中，如果有符合的元素，我们就把它加入结果集，同时判断其是否相等，相等我们就需要跳过下一个相等的元素）。
  - 反转数组：前后交换遍历即可
  - 求众数：使用投票算法，从前往后遍历，定义一个用于记录假设众数比非众数多的个数的变量count,从第一个开始先选择其为假设的众数，然后遍历，和它相等我们加count++, 不想等我们就count--, 如果count == 0我们就更换假设众数。在这个过程中因为最终的众数的个数一定是大于n/2的，因此我们最终更换的假设众数就一定是真的众数
  
- 快慢指针
  - 判断环形链表1：一快一慢，然后如果重合，就是有环
  - 判断环形链表2，找到环的入口：同样但是，碰到之后两指针速度都变为1,然后一个从链表头再开始遍历，一个从碰头的地方开始遍历就行了，再次相遇的地方就是链表头；
  - 倒数的第N个节点。快指针先轴N-1步，然后两个指针，同时慢指针从头开始开始遍历，直到快指针到尾巴那里，我们的慢指针指的那个指针就是倒数第n个节点.(此处我们的倒数第1个节点开始，没有倒数0个)；
  
- 滑动窗口：哈希双指针

  - 最小覆盖子串：定义两个哈希表map, ，right, left, valid一个用来记录被匹配字符串当中有哪些元素以及这些元素的个数，我们记need, 一个用来记录滑动窗口内已经匹配到的元素的map,windows，以及他们各自的数量。

    首先通过变量right从左开始遍历，对于每一个字符被加入到窗口的字符，我们需要先比较其是否在我们的need当中，然后再查看数量是否一致，如果是一致的，说明我们已经匹配完了一个元素，我们用一个变量valid记录，并且加1.如果我们的匹配完了，我们就开始通过left缩小窗口，如果碰到了窗口当中的元素，我们就把对应的windows中的元素个数减1，同时，判断其对应的个数是否比need窗口中的元素的个数是否要小，小了我们就，直到我们的窗口中的匹配元素（不重复）的个数减小了，我们才结束我们的窗口缩小，（left++期间我们在窗口缩小的时候要记录最小的子串的长度，和开始的位置，实时更新）继续扩大我们的right, 重复刚才的方法.知道right 遍历完整个的stirng：S

    

  - 最长无重复的子数组/最长无重复子字符串： 类似上面这一题，但是由于是判断重复，因此我们可以直接也是定义一个hashmap,但是我们这一题目，窗口扩大的条件是只要我们的元素是不重复的，我们就right++; 如果碰到了相同的，我们就缩小窗口，把left移动到重复的子元素的右边+1的位置，同时，我们在判断重复，移动left的时候，需要注意把left左边的被清除的元素给全部去除掉，我们可以加一个windows[arr[right]]  > left 给过滤掉，或者从left开始一个个元素，给remove掉也行。

  

  ```c++
  //1. 先定义 right left,标记
   int right ,left;
  //定义相应的记录滑动窗口内容的（被匹配）的map
  unorder_map<xx,xx>windows;
  //根据需要定义need的map.
  unorder_map<xx,xx>need;
  
  while(right < size()){
      //先移动right, 给窗口加入元素
      
      //根据需要（判断停止加入元素的时候），然后停止添加元素，进入缩小窗口的遍历循环
      
      while(left...){
          //同样根据需要判断停止缩小的条件，在这期间我们需要记录最有结果。
      }
  }
  ```

  

- 二分查找

- ```c++
  int binarySearch(int[] nums, int target) {
      int left = 0, right = ...;
  
      while(...) {
          int mid = left + (right - left) / 2;
          if (nums[mid] == target) {
              ...
          } else if (nums[mid] < target) {
              left = ...
          } else if (nums[mid] > target) {
              right = ...
          }
      }
      return ...;
  }
  //计算 mid 时需要防止溢出，代码中left + (right - left) 2就和(left + right) / 2的结果相同，但是有效防止了left和right太大直接相加导致溢出。
  ```

  

- 寻找一个数（基本的二分搜索）



```c++
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
```

- 为什么 while 循环的条件中是 <=，而不是 <**？

​		因为初始化`right`的赋值是`nums.length - 1`，即最后一个元素的索引，而不是`nums.length`。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间`[left, right]`，后者相当于左闭右开区间`[left, right)`，因为索引大小为`nums.length`是越界的。

我们这个算法中使用的是前者`[left, right]`两端都闭的区间。**这个区间其实就是每次进行搜索的区间**。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

`while(left <= right)`的终止条件是`left == right + 1`，写成区间的形式就是`[right + 1, right]`，或者带个具体的数字进去`[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)`的终止条件是`left == right`，写成区间的形式就是`[left, right]`，或者带个具体的数字进去`[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间`[2, 2]`被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。



- 为什么****`left = mid + 1`，`right = mid - 1`？我看有的代码是`right = mid`或者`left = mid`，没有这些加加减减，到底怎么回事，怎么判断**？

这是二分查找的一个难点,刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即`[left, right]`。那么当我们发现索引`mid`不是要找的`target`时，下一步应该去搜索哪里呢？

当然是去搜索`[left, mid-1]`或者`[mid+1, right]`,**因为`mid`已经搜索过，应该从搜索区间中去除**。



- 寻找左侧边界的二分搜索

```c++
 int right = nums.length; // 注意
 
 while (left < right)  // 注意
  
 if (nums[mid] > target) {
            right = mid; // 注意
 
```

- 为什么可行

关键在于对于`nums[mid] == target`这种情况的处理：

```
    if (nums[mid] == target)
        right = mid;
```

可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界`right`，在区间`[left, mid)`中继续搜索，即不断向左收缩，达到锁定左侧边界的目的

- 寻找右侧边界的二分查找

```c++
 if (nums[mid] == target) {
            left = mid + 1; // 注意
            
  return left - 1; // 注意
```

- 为什么可行？

关键点还是这里：

```
if (nums[mid] == target) {
    left = mid + 1;
```

当`nums[mid] == target`时，不要立即返回，而是增大「搜索区间」的下界`left`，使得区间不断向右收缩，达到锁定右侧边界的目的。



二分查找加归并排序：

- ​	归并统计法： **数组中的逆序对**

  - 归并统计法**

    相信大家都知道**归并排序**这个算法吧，如果不知道的，可以移至这里[排序](https://blog.nowcoder.net/n/7f89203eef22442383971c7911f632f7)先去学习一波~

    那么，我们先来说说归并算法吧，归并算法讲究一个先分后并！

    **先分**：分呢，就是将数组分为两个子数组，两个子数组分为四个子数组，依次向下分，直到数组不能再分为止！

    **后并**：并呢，就是从最小的数组按照顺序合并，从小到大或从大到小，依次向上合并，最后得到合并完的顺序数组！

    以上是归并排序，但是关键点在于合并环节，在合并数组的时候，当发现右边的小于左边的时候，此时可以直接求出当前产生的逆序对的个数。

    在合并 {4 ,5} {1 , 2} 的时候，首先我们判断 1 < 4，我们即可统计出逆序对为2，为什么呢？这利用了数组的部分有序性。因为我们知道 {4 ,5} 这个数组必然是有序的，因为是合并上来的。此时当 1比4小的时候，证明4以后的数也都比1大，此时就构成了从4开始到 {4,5}这个数组结束，这么多个逆序对（2个），此时利用一个临时数组，将1存放起来，接着比较2和4的大小，同样可以得到有2个逆序对，于是将2也放进临时数组中，此时右边数组已经完全没有元素了，则将左边剩余的元素全部放进临时元素中，最后将临时数组中的元素放进原数组对应的位置。

    

![](C:\Users\86181\Desktop\23.png)



- 双指针补充
  - 反转字符串/判断是否为回文字符串：一个往前遍历，一个往后遍历，交换字符的位置
  - 合并重复的区间：我们首先按照区间的起始元素进行升序排序，这样就保证了上一个区间的起始元素一定小于下一个区间的起始元素，便于操作。然后就开始遍历，但是在遍历的时候，我们需要注意一点技巧。我们可以先将第一个区间直接放进我们的返回容器中，这样的话我们从第二个开始遍历，然后用返回容器中存的前面区间当中最大的元素，来和正在遍历的区间当中元素来做比较。如果重叠，我们就直接修改最大元素。不重叠，我们就直接将现在遍历的区间加入到返回容器中，做为新一轮区间遍历的起始。
  - 合并两个有序数组：先开辟一个返回数组，然后我们对两个数组进行遍历，然后分别从两个数组当中拿到一个元素，比较大小，小的那个我们就加入到我们的返回数组中，然后对应的有序数组往后偏移，另一个别动。然后循环，进入下一轮比较。最后必定有一个数组先被遍历完，此时结束循环，我们将未被遍历完的数组，直接加到返回数组的后面。注意我们要判别特殊情况，一个为空，一个不为空，以及两个都为空的特殊情况
  - 盛水最多的容器：，用两个指针，一个指向开头，一个指向结尾，然后我们每次移动一个指针，这时候我们要考虑一个问题，我们要移动哪一个指针，我们看到这个公式，我们可以思考一下，我们每次移动指针，两个板子之间的距离都是会变小，那么我们要是尽可能的想让我们总存水量变大，那么我们就要让我们两个板子之间的最小值变大（因为最小值决定了我们盛水容器的高度），我们移动大的那个指针只会让我们的答案不变或者变小，所以我们只有移动小的那个指针才可以达到变化的一个作用。所以我们一前一后，开始遍历，逐个遍历，偏移小的，然后判断最大值，直到遍历完成
  - 接雨水：用俩个指针，一个指向开头，一个指向结尾。然后我们再定义连个代表装雨水的容器的左右高度的指针。maxl(开头),maxr（结尾）。因为只有当我们的左右更高，我们才可以装下雨水。然后我们的每一层通过左边到这一层的最高减去这一层的高度就得到了这一层可以装下的水。然后，由于我们是高度更低的代表我们可以装的水的极限，因此我们如果是左边的碗高更低我们就从左边开始，如果是右边碗高更低我们就从右边开始。
  





-  链表内指定区间反转：
  - 方法1.要反转局部链表，可以将该局部部分当作完整链表进行反转，再将已经反转好的局部链表与其他节点建立连接，重构链表，使用虚拟头节点的技巧，可以避免对头节点复杂的分类考虑，简化操作。
  - 方法2.最优解
  - 在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。
    - `curr`：指向待反转区域的第一个节点 left；
    - `Cur_next`：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 Cur_next 会变化；
    - `pre`：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。
  - 实现流程以及步骤
    - ![](C:\Users\86181\Desktop\数据结构与算法\image\7BB5BF1ECAE4CE6E18583D9D299A3924.png)







##### 二叉树

**层序遍历**：主要思路：BFS广度优先
如下图所示：一层一层的遍历二叉树，
1、遍历到一个节点，将左右个孩子加入队列；
2、一次遍历二叉树的一层；
3、怎么确定能遍历一层：每次遍历队列，先记录队列的大小size，出队size次，这些值即为一层，存入res数组，并通过1、2将下一层的节点存入队列；

```c++
 * struct TreeNode {
 *    int val;
 *    struct TreeNode *left;
 *    struct TreeNode *right;
 * };
 */
 
class Solution {
public:
    /**
     *
     * @param root TreeNode类
     * @return int整型vector<vector<>>
     */
    vector<vector<int> > levelOrder(TreeNode* root) {
        // write code here
        vector<vector<int> > vv;
        if(!root){
            return vv;//二叉树为空
        }
        queue<TreeNode*> qq;//队列存放相邻两层节点；
        qq.push(root);
        while(!qq.empty()){
            vector<int> tempv;
            int size=qq.size();
            for(int i=0;i<size;++i){//将一层的节点size出队；
                TreeNode* tt=qq.front();
                qq.pop();
                tempv.push_back(tt->val);
                //将下一层的节点入队；
                if(tt->left)qq.push(tt->left);
                if(tt->right)qq.push(tt->right);
            }
            vv.push_back(tempv);//加入将要返回的数组中；
        }
        return vv;//返回最终结果
    }
};
```

- **按之字形顺序打印二叉树**

  - 算法思想：层次遍历+双端队列（奇偶层逻辑分离）
    - 解题思路：
      - 方法一代码简短、容易实现；但需要判断每个节点的所在层奇偶性，即冗余了 N 次判断。通过将奇偶层逻辑拆分，可以消除冗余的判断。

  **算法流程：**

  层次遍历此方法使用的是双端队列存储二叉树的节点

  BFS 循环： 循环打印奇 / 偶数层，当 deque 为空时跳出；
  1、打印奇数层： 从左向右 打印，先左后右 加入下层节点；
  2、若 deque 为空，说明向下无偶数层，则跳出；
  3、打印偶数层： 从右向左 打印，先右后左 加入下层节点；

```c++
class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int>>rvec;
        queue<TreeNode*>que;
        if(pRoot == nullptr) return {}; 
        que.push(pRoot);
        vector<int>row;
        bool isSig = true;
        while(!que.empty()){
            int n = que.size();
            
            for(int i = 0; i < n; i++){
                TreeNode*  node = que.front();
                row.push_back(node->val);
                que.pop();
                if(node->left)
                    que.push(node->left);
                if(node->right)
                    que.push(node->right);
            }
            if(isSig){
                rvec.push_back(row);
            }else{
                reverse(row.begin(), row.end());
                rvec.push_back(row);
            }
            row.clear();
            isSig = !isSig;
        }
        return rvec;
    }
    
};
```

- **二叉树最大深度**

  - 运用dfs的思想，深度优先遍历。 层次遍历也可以

  - 递归边界： 当root的为空，返回0
    递归过程： 计算root左子树深度和root右子树深度

  - ```c++
    class Solution {
    public:
        int maxDepth(TreeNode* root) {
            if(!root) return 0;  //递归边界
             return max(maxDepth(root->left),maxDepth(root->right))+1;  //计算左子树和右子树深度取大者最后+1 = 树的深度
        }
    };
    ```

    

- 和为指定值的路径

  - 采用递归遍历二叉树的路径节点，同时计算二叉树路径节点的数字之和，当到达叶子节点且路径的数字之和等于 sum 则说明二叉树中存在节点和为指定值的路径

    **算法步骤：**

    1、特殊情况：当二叉树为空，则返回 false

    2、遍历根节点的左右子树，记录根节点的数字之和 res

    当节点的左右子树均为空，且 res == sum，则返回 true

    3、递归 该节点的左右子树，做上述计算

    ```c++
    class Solution {
    public:
        /**
         * 
         * @param root TreeNode类 
         * @param sum int整型 
         * @return bool布尔型
         */
        bool hasPathSum(TreeNode* root, int sum) {
            // write code here
            if(root == nullptr)return false;
            if(root->left == nullptr && root->right == nullptr && sum - root->val == 0) return true;
            
            return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
        }
    };
    ```

- **二叉树转换&&双向链表**

算法思想：中序遍历

1、特殊情况，二叉树为空，则直接返回 null

2、创建 保留上一个结点 pre，返回链表结点 root

3、递归遍历左子树；root = pRootOfTree

4、遍历当前结点，并修改为双向链表 pRootOfTree.left=pre; pre.right=pRootOfTree; 

5、更新 pre = pRootOfTree

6、递归遍历右子树

7、递归结束返回 root

```c++
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree) {
        TreeNode* pRoot = pRootOfTree;
        if(pRootOfTree == nullptr)return nullptr;
        while(pRootOfTree->left != nullptr){
            pRootOfTree = pRootOfTree->left;
        }
        function(pRoot);
        return pRootOfTree;
    }
    TreeNode* function(TreeNode* pRootOfTree){
        if(pRootOfTree == nullptr) return nullptr;
        function(pRootOfTree->left);
        if(pTreeTail == nullptr){
            pTreeTail = pRootOfTree;
        }else{
            pTreeTail->right = pRootOfTree;
            pRootOfTree->left = pTreeTail;
            pTreeTail = pTreeTail->right;
        }
        function(pRootOfTree->right);
        return nullptr;
    }
private:
    TreeNode* pTreeTail = nullptr;
};
```

**对称的二叉树**

**算法流程**：

**isSymmetrical**(root) ：
  特例处理： 若根节点 root 为空，则直接返回 truetrue 。
  返回值： 即 dfs(root.left, root.right) ;
**dfs**(L, R) ：
  终止条件：
    当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；
    当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；
    当节点 L值 / 节点 R 值： 此树不对称，因此返回 falsefalse ；
  递推工作：
    判断两节点 L.left 和 R.right 是否对称，即 dfs(L.left, R.right) ；
    判断两节点 L.right 和 R.left 是否对称，即 dfs(L.right, R.left) ；
  返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 && 连接

```c++
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot) {
        if(pRoot == nullptr)return true;
        return Function(pRoot->left, pRoot->right);
    }
private:
    bool Function(TreeNode* pRoot1, TreeNode* pRoot2){
        if(pRoot1 == nullptr && pRoot2 == nullptr )return true;
        //注意，我们不可以在某个节点里面来就直接返回真，只可以在终止节点里面返回真。
        if(pRoot1 == nullptr ||pRoot2 == nullptr ||pRoot1->val != pRoot2->val) return false;
       
        return Function(pRoot1->left, pRoot2->right) && Function(pRoot1->right, pRoot2->left);
    }
};
```

**合并二叉树**

采用前序遍历的方式，根左右，返回节点。

```c++
class Solution {
public:
    /**
     * 
     * @param t1 TreeNode类 
     * @param t2 TreeNode类 
     * @return TreeNode类
     */
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        // write code here
        if(t1 == nullptr){
            return t2;
        }
        
        if(t2 == nullptr){
            return t1;
        }
        
        t1->val += t2->val;
        t1->left = mergeTrees(t1->left, t2->left);
        t1->right = mergeTrees(t1->right, t2->right);
        
        return t1;
    }
    
private:
    TreeNode* Rt = nullptr;
};
```



**二叉树的镜像**

根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。

解题步骤：

1、特判：如果pRoot为空，返回空

2、交换左右子树
3、把pRoot的左子树放到Mirror中镜像一下
4、把pRoot的右子树放到Mirror中镜像一下
5、返回根节点root

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pRoot TreeNode类 
     * @return TreeNode类
     */
    TreeNode* Mirror(TreeNode* pRoot) {
        // write code here
        if(pRoot == nullptr)return nullptr;
        Mirror(pRoot->left);
        Mirror(pRoot->right);
        
        TreeNode* left = pRoot->left;
        TreeNode* right = pRoot->right;
        pRoot->right = left;
        pRoot->left = right;
        
        return pRoot;
    }
};
```



**判断是不是二叉搜索树**

,采用递归，中序遍历，借鉴二叉搜索树与双向链表的思路。

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return bool布尔型
     */
    bool isValidBST(TreeNode* root) {
        // write code here
        if(root == nullptr) return true;
        bool b1 = isValidBST(root->left);
        if(pTemp != nullptr){
            if(pTemp->val >= root->val)return false;
        }
        pTemp = root;
        bool b2 = isValidBST(root->right);
        
        return b1 && b2;
    }
private:
    TreeNode* pTemp = nullptr;
};
```

**判断是不是完全二叉树**

- 采用层序遍历，因为如果是完全二叉树，输出的节点就是连续的，直到没有节点了，如果不是，那么输出的节点就是不连续的。

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return bool布尔型
     */
    bool isCompleteTree(TreeNode* root) {
        // write code here
        if(root == nullptr) return true;
        
        queue<TreeNode*>que;
        que.push(root);
        bool isNull = false;
        while(!que.empty()){
            int n = que.size();
            for(int i = 0; i < n; i++){
                TreeNode* node = que.front();
                que.pop();
                
                if(!node){
                    isNull = true;
                }else{
                    if(isNull) return false;
                    que.push(node->left);
                    que.push(node->right);
                }
            }
        }
        return true;
    }
};
```

**二叉搜索树的最近公共祖先**

考虑到二叉搜索树的性质，采用二分搜索遍历的方式，可以直接找到

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param p int整型 
     * @param q int整型 
     * @return int整型
     */
    int lowestCommonAncestor(TreeNode* root, int p, int q) {
        // write code here
        if(root == nullptr) return -1;
        int max = -1;
        int min = -1;
        if(p > q){
            max = p;
            min = q;
        }else{
            max = q;
            min = p;
        }
        
        if(max >= root->val && root->val >= min){
            res = root->val;
            return res;
        }else  if(root->val > max){
            res = lowestCommonAncestor(root->left,  p , q);
        }else {
           res =  lowestCommonAncestor(root->right,  p, q);
        } 
        
        return res;
        
    }
private:
    int res;
};
```





**二叉树的最近公共祖先**

遍历过程中，有几个情况：

- 都在左边或者右边
- 在两边，此时这个是公共祖先
- 只有其中一个节点

```c++
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        // write code here
        if(root == nullptr )return -1;
        
        if(root->val == o1 || root->val == o2){
            return root->val;
        }
        
        int right = lowestCommonAncestor(root->right, o1, o2);
        int left = lowestCommonAncestor(root->left, o1, o2);
        
        if(right == -1)return left;
        if(left == -1) return right;
        
        return root->val;
    }
};
```

**序列化二叉树**

- 解题思路：首先我们根据题意采用先序遍历对二叉树进行遍历，在遍历过程中进行序列化操作，对于空的节点，我们用#代替，字符和字符之间，用，隔开
- 反序列化，因为我们是通过先序遍历来进行的序列化，同时由于我们对于空节点是有#标志的，因此我们可以通过递归来完成我们的反序列化。



```c++
class Solution {
public:
    char* Serialize(TreeNode *root)
    {
        SerializeFunction(root);
        int size = resStr.size() + 1;
        char* str = new char[size];
        strcpy(str, resStr.c_str());
        str[size] = '\0';
        return str;
    }
    void SerializeFunction(TreeNode* root){
        if(root == nullptr){
            resStr.append("#").append(",");
            return;
        }
        string ch = to_string(root->val); 
        resStr.append(ch).append(",");
        SerializeFunction(root->left);
        SerializeFunction(root->right);
    }
    
       
    TreeNode* Deserialize(char *str)
    {
        int i = 0;
        TreeNode* root = DeserializeFunction(str, i);
        return root;
    }
    TreeNode* DeserializeFunction(char *str, int& i){
        if(str[i] ==  '#'){
            return nullptr;
        }
        int val = 0;
        while(str[i] != ',' && str[i] != '\0'){
            val = val*10 + str[i] - '0';
            i++;
        }
        
        TreeNode* node = new TreeNode(val);
        
        if(str[i] == ','){
            i++;
        }else if(str[i] == '\0'){
            return nullptr;
        }else {
            node->left = DeserializeFunction(str, i);
            node->right = DeserializeFunction(str, i);
        }
        return node;
    }
private:
    string resStr;
};
```

**重建二叉树**

二叉树的**前序遍历：****根****左右；中序遍历：左根右**

设置三个指针，一个是preStart，表示的是前序遍历开始的位置，一个是inStart，表示的是中序遍历开始的位置。一个是inEnd，表示的是中序遍历结束的位置，我们主要是对中序遍历的数组进行拆解。

、、可以通过hash表优化。

```c++
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        int m = pre.size();
        int n = vin.size();
        
        if(m == 0 || n == 0){
            return nullptr;
        }
        
        TreeNode* root = new TreeNode(pre[0]);
        int i = 0;
        while(i < n){
            if(pre[0] == vin[i]){
                vector<int>leftPre(pre.begin() + 1, pre.begin() + i + 1 );
                vector<int>leftVin(vin.begin(), vin.begin() + i);
                root->left = reConstructBinaryTree(leftPre, leftVin);
                vector<int>rightPre(pre.begin() + i + 1, pre.end());
                vector<int>rightVin(vin.begin() + i + 1, vin.end());
                root->right = reConstructBinaryTree(rightPre, rightVin);
                break;
            }
            i++;
        }
        return root;
    }
};
```

**输出二叉树的右视图**

首先我们可以通过上图的方法建立二叉树，然后通过BFS拿到每一层最右的节点。因为我们可以拿到每一层的节点数。

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 求二叉树的右视图
     * @param xianxu int整型vector 先序遍历
     * @param zhongxu int整型vector 中序遍历
     * @return int整型vector
     */
    unordered_map<int, int>vimIndex;
    vector<int> solve(vector<int>& xianxu, vector<int>& zhongxu) {
        // write code here
        for(int i = 0; i < zhongxu.size(); i++){
            vimIndex[zhongxu[i]] = i;
        }
        TreeNode* root = buildTree(xianxu, 0, xianxu.size() - 1, zhongxu, 0, zhongxu.size() - 1);
        
        vector<int>resVec;
        
        queue<TreeNode*>que;
        que.push(root);
        
        while(!que.empty()){
            int n = que.size();
            for(int i = 0; i < n; i++){
                TreeNode *node= que.front();
                if(i == n - 1){
                    int val = node->val;
                    resVec.push_back(val);
                }
                if(node->left)que.push(node->left);
                if(node->right)que.push(node->right);
                que.pop();
            }
        }
        
        return resVec;
    }
    
    TreeNode* buildTree(vector<int>& pre, int p1, int p2, vector<int>& vim, int v1, int v2 ){
        int m = p2 - p1;
        int n = v2 - v1;
        if(m < 0 || n < 0)return nullptr; //注意这两个 必须要是小于0 ，而不是小于等于0
        
        int middle = pre[p1];
        TreeNode* root = new TreeNode(middle);
        
        int index = vimIndex[middle];
        int leftsize = index - v1;
        root->left = buildTree(pre, p1 + 1, p1 + leftsize, vim, v1, index - 1);
        root->right = buildTree(pre, p1 + leftsize + 1, p2, vim, index + 1, v2);
        
        return root;
    }
    
};
```

##### 堆/栈/队列

**用两个栈实现队列**

- 借助栈的**先进后出**规则模拟实现队列的**先进先出**

**1、**当插入时，直接插入 stack1

2、当弹出时，当 stack2 不为空，弹出 stack2 栈顶元素，如果 stack2 为空，将 stack1 中的全部数逐个出栈入栈 stack2，再弹出 stack2 栈顶元素

```c++
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        while(!stack1.empty()){
            int node = stack1.top();
            stack1.pop();
            stack2.push(node);
        }
        int resNode = stack2.top();
        stack2.pop();
        while(!stack2.empty()){
            int node = stack2.top();
            stack2.pop();
            stack1.push(node);
        }
        return resNode;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```

**包含min函数的栈**

双栈法：一个存的是正常的数字，另一个我们维护的是，到目前为止，我们加进来的数字里面的最大值。

```c++
class Solution {
public:
    void push(int value) {
        st1.push(value);
        if(st2.empty() || st2.top() > value){
            st2.push(value);
        }else{
            st2.push(st2.top());
        }
    }
    void pop() {
        st1.pop();
        st2.pop();
    }
    int top() {
        return st1.top();
    }
    int min() {
        return st2.top();
    }
    stack<int>st1;
    stack<int>st2;
};
```

**有效括号序列**

**借助辅助栈——左括号入栈**
**核心思想：**
    每次遇到'(','{','['这三种字符的时候，将字符入栈stk；而每次遇到')','}',']'这三种字符的时候则让对应的匹配字符出栈。具体规则如下：
1）引入辅助栈stk，遍历字符串，每次遇到'(','{','['字符的时候将字符入栈stk
2）当遇到')','}',']'字符的时候，则检查栈是否空，且顶元素是否为匹配元素（如{和}匹配等），如果栈空或者栈顶元素不为匹配元素则括号序列不合法
3）当栈非空，且栈顶元素为匹配元素，则栈顶元素出栈。
4）循环匹配字符串，直到每次字符处理完
5）检查栈stk是否为空，栈为空则序列合法，否则不合法（当括号以正确顺序关闭时则最后的栈为空）

```c++
class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool isValid(string s) {
        // write code here
        unordered_map<char, char>map;
        map['('] = ')';
        map['{'] = '}';
        map['['] = ']';
        for(int i = 0; i < s.size(); i++){
            char ch = s[i];
            if(ch == '(' || ch == '[' || ch == '{'){
                st.push(ch);
            }else{
                if(st.empty()){
                    return false;
                }
                char ch1 = st.top();
                st.pop();
                if(map[ch1] != ch){
                    return false;
                }
            }
        }
        if(!st.empty()) return false;
        return true;
    }
    
private:
    stack<char>st;
};
```

**滑动窗口的最大值**

**思路：单调队列**

1. 单调队列的特点就是从队头到队尾的元素都是单调的，对于本题来说，我们也可以用单调队列来维护滑动窗口的最大值，并且使用单调队列，每次操作的时间复杂度都是线性的，可以更好地优化时间复杂度
2. 同样，为了方便排除不在窗口中的元素，我们的单调队列中存放的是下标而不是元素，这样我们可以计算长度是否满足窗口大小，特别地，我们的单调队列不是一般的队列，而是支持尾部进队出队和头部出队的数据结构，因此我们可以使用C++标准库提供的双端队列deque来实现单调递减队列
3. 算法流程：首先，若队列为空，则直接入队，不为空，则比较队尾所表示的元素是否小于待入队的元素，若小于，则不断出队，知道队列为空或队尾元素小于等于待入队的元素，这样队头到队尾就形成了一个单调不增的序列；然后我们需要查看一下当前队头元素是否合法，即它的下标是否存在于当前的滑动窗口内，若不存在，则出队。由于滑动窗口每向右移动一次，只会有一个元素出队一个元素入队，因此队头元素不合法的至多只有一个；最后，我们取出队头元素加入答案数组中即可

```c++
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& nums, int size) {
        deque<int>dq;
        vector<int>resVec;
        for(int i = 0; i < nums.size(); i++){
            while(!dq.empty() && nums[i] > nums[dq.back()]){
                dq.pop_back();
            }
            dq.push_back(i);
            if(i - dq.front() + 1 > size){
                dq.pop_front();
            }
            if(i >= size-1) resVec.push_back(nums[dq.front()]);
        }
        return resVec;
    }
};
```

**最小的K个数**

**堆，优先级队列**

1. 堆(优先队列)这一数据结构可以支持O(logn)的插入和堆顶出队操作, 因此我们可以用一个大小为k的大根堆来维护数组最小的k个数
2. 算法实现：当堆的大小小于k时, 直接插入即可; 当堆的大小等于k时, 将当前待插入元素与堆顶元素进行比较, 如果小于堆顶元素, 则堆顶出堆, 当前元素入堆, 否则不插入当前元素, 最后堆中就保留了最小的k个数, 我们再将其取出即可

```c++
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        int n = input.size();
        if(k > n)return input;
        
        vector<int>resVec;
        resVec.clear();
        priority_queue<int>pq;//大顶堆
        
        for(int i = 0; i < input.size(); i++){
            if(pq.size() < k){
                pq.push(input[i]);
            }else if(!pq.empty() && input[i] < pq.top()){//加上判空，可能遇到等于0的情况
                pq.pop();
                pq.push(input[i]);
            }
        }
        
        while(!pq.empty()){
            resVec.push_back(pq.top());
            pq.pop();
        }

        return resVec;
    }
};
```

 **寻找第K大**

**快排+二分查找**

一、二分查找是利用快速排序的二分特点
利用快排在排序时，把数组分成两部分，一部分小于一个值，另一部分大于这个值的特点
将数组用快排从大到小排序，取temp值为数组的第一个数a[start],那么经过一轮调整之后，数组左边的所有值大于或等于temp，数组右边的所有值都小于或等于temp，假设此时temp是数组第i个数。
如果i正好等于K，那么temp就是第K大值
如果i大于K，那么说明第K大值在数组左边，则继续在左边查找
如果i小于K，那么说明第K大值在数组的右边，继续在右边查找
每一轮排序都重复上述步骤，直到找到第K大值。

```c++
class Solution {
public:
    int findKth(vector<int> a, int n, int K) {
     int res = quickSort(a, 0, n-1, K);   
     return res;
    }
    
    int quickSort(vector<int>& vec, int low, int high, int k){
        int p = partion(vec, low,  high); //分区函数
        
        if(p - low + 1 == k) return vec[p];
        
        if(p - low + 1 > k) return quickSort(vec, low, p - 1, k);
        
        if(p - low + 1 < k) return quickSort(vec, p + 1, high, k-(p-low+1));
        return vec[p];
    }
    
    int partion(vector<int>& vec, int low, int high){
        int i = low;
        int j = low;
        int mid = (low+high)/2;
        int temp = vec[mid];
        vec[mid] = vec[high];
        vec[high] = temp;
        
        while(j < high){
            if(vec[j]  > temp){
                if(i != j){
                    int num = vec[j];
                    vec[j] = vec[i];
                    vec[i] = num;   
                }
                i++;
            }
            j++;
        }
        if(i != j){
            int num = vec[j];
            vec[j] = vec[i];
            vec[i] = num;
        }
        return i;
    }
};
```

**数据流中的中位数**

**大顶堆，小顶堆**

1. 本题是对顶堆算法的一个经典题，所谓对顶堆算法，实际上就是使用一个小顶堆和一个大顶堆
2. 对于求动态中位数的问题，我们可以利用堆的性质，可以在logn的时间复杂度取出最大值或最小值，那么我们可以用大顶堆维护前一半的数，用小顶堆维护后面一半的数
3. 我们规定，若元素总数为奇数，那么大顶堆的元素个数要比小顶对的个数多1，这样，当总数为奇数时，中位数就是大顶堆的堆顶元素；当总数为偶数时，中位数就大顶堆堆顶和小顶堆堆顶元素的平均值

```c++
class Solution {
public:
    void Insert(int num) {
        min.push(num); //筛选出最大值
        max.push(min.top());
        min.pop();
        
        if(min.size() < max.size()){
            min.push(max.top());
            max.pop();
        }
    }

    double GetMedian() { 
        int numbers = min.size() + max.size();
        
        if(numbers % 2 == 0)return (double)(min.top() + max.top())/2;
        
        if(numbers % 2 == 1)return (double)min.top();
        return 0;
    }
private:
    priority_queue<int>min; // 大顶堆
    priority_queue<int, vector<int>, greater<int>> max;  // 小顶堆
};
```

**表达式求值**

单独采用栈，我们将要+ -的操作数给入栈，将括号里的算式给进行递归，然后我们往栈当中加入数字，完成之后我们再将栈当中的数字全部给出栈，然后相加

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 返回表达式的值
     * @param s string字符串 待计算的表达式
     * @return int整型
     */
    int solve(string s) {
        // write code here
        return function(s, 0)[0];
    }
    
    vector<int> function(string& s, int index){
        stack<int>st;      //不要错写了，栈内元素的类型
        int size = s.size();
        int num = 0;
        char op = '+';
        int i = 0;
        for(i = index; i < size; i++){
             if(isdigit(s[i])){
                num = num*10 + (s[i]-'0');
                 if(i != size - 1)
                    continue;
            }
            
            if(s[i] == '('){
                vector<int>res = function(s, i+1);
                i = res[1];
                num = res[0];
                if(i != size - 1)
                    continue;
            }
            
            switch(op){
                case '+':
                    st.push(num);
                    break;
                case '-':
                    num = 0 - num;
                    st.push(num);
                    break;
                case '*':
                    int temp = st.top();
                    st.pop();
                    num = num * temp;
                    st.push(num);
                    break;
            }
             num = 0;
            if(s[i] == ')'){
               break;
            }else{
                op = s[i];
            }
        }
        int sum = 0;
         while(!st.empty()){
                    sum += st.top();
                    st.pop();
                }
         return vector<int>{sum, i};
    }
};
```

##### 哈希

**两数之和**

由题意，自然可知我们用hash最快

```c++
class Solution {
public:
    /**
     * 
     * @param numbers int整型vector 
     * @param target int整型 
     * @return int整型vector
     */
    vector<int> twoSum(vector<int>& numbers, int target) {
        // write code here
        unordered_map<int, int>map;
        
        for(int i = 0; i < numbers.size(); i++){
            int num = target - numbers[i];
            if(map.find(num) != map.end()){
                return vector<int>{map[num]+1, i+1};
            }
            map.insert(make_pair(numbers[i], i));
        }
        return {};
        
        
    }
};
```

 **数组中出现次数超过一半的数字**

使用hash表直接进行统计比较

```c++
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        unordered_map<int, int>map;
        int size = numbers.size();
        for(auto& num : numbers){
            map[num]++;
            if(map[num] > size/2){
                return num;
            }
        }
        return -1;
    }
};
```

**数组中只出现一次的两个数字**

**异或**

异或的特性是：两个数字相同，则异或结果为0，两个数字不同，则其二进制位的异或结果为 1，如 4 ^ 6 = 100 ^ 110 = 010。

异或运算一般要将数字转化为二进制位，再进行运算，相同则为0，不同则为 1。

因此，看到数组里**其他数字都出现两次**，那么就应该联想到异或的特性，使得所有元素异或后，出现两次的数字异或都都为0。

因此异或结果后就只剩下两个只出现一次的数字，接下来问题就好解决多了。

**2 分治思想，问题降维**

通过与运算求出两个目标值的**异或结果的最右边的 1** 作为标记

通过 mark 与数组每个元素的异或结果不同，将数组分为**两组**，分别存放到结果集里

反正相同的两个数组都会分到同一组

两组分别异或后结果都会只下最后的两个单独数字

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型vector 
     * @return int整型vector
     */
    vector<int> FindNumsAppearOnce(vector<int>& array) {
        // write code here
        unordered_map<int, int>map;
        vector<int>res;
        int res1 = 0;
        int res2 = 0;
        int temp = 0;
        
        for(auto& num : array){
            temp ^= num;
        }
        
        int k = 1;
        while((k & temp) == 0){
            k <<= 1;
        }
        
        for(auto& num : array){
            if((k & num) == 0){
                res1 ^= num;
            }else{
                res2 ^= num;
            }
        }
        
        if(res1 > res2){
            return{res2, res1};
        }else{
            return{res1, res2};
        }
        return {};
    }
};
```

**缺失的第一个正整数**

**hash**

- 首先遍历整个数组，并用unordered_map标记该数字已出现
- 然后从1遍历到n，并在unordered_map查找该值是否出现，未出现则直接返回
- 若长度为n的数组里n个数字都出现了，则第n+1个数字一个未出现

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    int minNumberDisappeared(vector<int>& nums) {
        // write code here
        unordered_map<int, int>map;
        for(auto& num : nums){
            map[num]++;
        }
        
        int res = 1;
        while(map.find(res) != map.end()){
            res++;
        } 
        
        return res;
    }
};
```

**三数之和**

**双指针，排序**

算法流程：

1、特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []。
2、对数组进行排序。
3、遍历排序后数组：
  1、若 num[i]>0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。
  2、对于重复元素：跳过，避免出现重复解
  3、令左指针 L=i+1，右指针R=n−1，当 L<r 时=""> </r>

​    1、当 nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R移到下一位置，寻找新的解
​    2、若和大于 0，说明 nums[R] 太大，R 左移
​    3、若和小于 0，说明 nums[L] 太小，L 右移

```c++
class Solution {
public:
    vector<vector<int> > threeSum(vector<int> &num) {
        sort(num.begin(), num.end());
        vector<vector<int>>vecRes;
        int start = 0;
        int end = num.size() - 1;
        int temp = 0;
        int num3 = 0;
        while(temp < num.size()){
            start = temp + 1;
            end = num.size() - 1;
            while(start < end){
                int num1 = num[start];
                int num2 = num[end];
                    num3 = num[temp];
                int target = num1 + num2 + num3;
                
                if(target == 0){
                    
                    vector<int>vec;
                    vec.push_back(num1);
                    vec.push_back(num2);
                    vec.push_back(num3);
                    vecRes.push_back(vec);
                    
                    while(++start < end && num[start] == num1);
                    while(--end > start && num[end] == num2);
                    
                }else if(target < 0){
                    start++;
                }else{
                    end--;
                }
            }
            while(++temp < num.size() && num[temp] == num3);
        }
        return vecRes;
    }
};
```





##### 递归/回溯

**没有重复项数字的全排列**

![](C:\Users\86181\Desktop\数据结构与算法\image\5393CFC54FE322C6A9EDCD6160164589.png)

```c++
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        sort(num.begin(), num.end());
        vector<vector<int>> vecRes;
        function(vecRes, num, 0);
        return vecRes;
    }
    
    void function(vector<vector<int>> &vecRes, vector<int> &num, int index){
        if(index == num.size()-1){
            vecRes.push_back(num);
        }else{
            for(int i = index; i < num.size(); i++){
                swap(num[i], num[index]); //选择对应的数字进行递归
                function(vecRes, num, index+1);
                swap(num[i], num[index]);//撤销我们对应的选择
            }
        }
    }
};
```

**有重复项数字的全排列**

这道题目跟[没有重复项数字的所有排列](https://www.nowcoder.com/practice/4bcf3081067a4d028f95acee3ddcd2b1?tpId=196&&tqId=37074&rp=1&ru=/ta/job-code-total&qru=/ta/job-code-total/question-ranking) 的做法其实是类似的，只不过区别在于有了重复的数字，如果不加以处理，还是按照原来的方法去做的话，那么就可能会出现重复的结果。我们使用两个map来进行去重，同时为了保证结果的有序性，我们还要提前将num排序，同时按顺序选择num中的元素，而**不是原地操作**

![](C:\Users\86181\Desktop\数据结构与算法\image\54A138646EBFD5C5E1B1E01124D0AF82.png)

```c++
class Solution {
public:
    vector<vector<int> > permuteUnique(vector<int> &num) {
        sort(num.begin(), num.end());
        vector<vector<int>>vecRes;
        vector<int>temp;
        unordered_map<int, int>mark;
        function(vecRes, num, temp, mark);
        return vecRes;
    }
    
    void function(vector<vector<int>>&vecRes, vector<int>&num, vector<int>&temp, unordered_map<int, int>&mark){
        if(temp.size() == num.size()){
            vecRes.push_back(temp);
            return;
        }else{
            unordered_map<int, int>map;
            for(int i = 0 ; i < num.size(); i++){
                temp.push_back(num[i]);
                if(mark.find(i) == mark.end()){//已经加入结果集的对应下标的元素，不可以加入
                    if(map.find(num[i]) == map.end()){
                        mark.insert(make_pair(i, 1));  //记录我已经加入了对应下标元素为结果集
                        map.insert(make_pair(num[i], 1));//记录这一层的已经加入的相同的元素。
                        function(vecRes, num, temp, mark); 
                        mark.erase(i); //撤销回溯， 注意我们撤销的时机，以及记录的时机
                    }
                }
                temp.pop_back();//撤销回溯
            }
        }
    }
};
```

**岛屿数量**

深度优先搜索

从一个为1的根节点开始访问，从每个相邻1节点向下访问到顶点（周围全是水），依次访问其他相邻1节点到顶点
时间复杂度 : O(M×N)，其中 M 和 N 分别为行数和列数。
空间复杂度 : 最坏情况下为 O(M×N)，此时整个网格均为陆地，深度优先搜索的深度达到 M×N。

```c++
class Solution {
public:
    /**
     * 判断岛屿数量
     * @param grid char字符型vector<vector<>> 
     * @return int整型
     */
    int solve(vector<vector<char>>& grid) {
        // write code here
        if(grid.size() == 0)return 0;
        int count = 0;
        int m = grid.size();
        int n = grid[0].size();
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++){
                if(grid[i][j] == '1'){
                    count++;
                    dfs(grid, i, j);
                }
            }
        return count;
    }
    
    void dfs(vector<vector<char>>& grid, int i, int j){
        if(grid[i][j] == '0')return;
        grid[i][j] = '0';
        if(i - 1 >= 0){
            dfs(grid, i-1, j);     
        }
        
        if(j - 1 >= 0){
            dfs(grid, i, j-1);
        }
        
        if(i + 1 < grid.size()){
            dfs(grid, i + 1, j);
        }
        
        if(j + 1 < grid[0].size()){
            dfs(grid, i, j + 1);
        }
    }
};
```

**字符串的全排列**

![](C:\Users\86181\Desktop\数据结构与算法\image\XXXX.PNG)

```c++
class Solution {
public:
    vector<string> Permutation(string str) {
        sort(str.begin(), str.end());
        vector<string>vecRes;
        function(str,  vecRes, 0);
        return vecRes;
    }
    
    void function(string& str, vector<string>& vecRes, int index){
        if(index == str.length()){
            vecRes.push_back(str);
        }else{
            unordered_map<char, int>mark;//去重，防止重复选择
            for(int i = index; i < str.length(); i++){
                swap(str[i], str[index]);
                if(mark.find(str[index]) == mark.end()){
                    function(str, vecRes, index+1);
                    mark.insert(make_pair(str[index], 1));//标记，防止重复
                }
                swap(str[i], str[index]);//回溯
            }
        }
    }
};
```

**N皇后问题**

直接采用回溯即可。

```c++
class Solution {
public:
    /**
     * 
     * @param n int整型 the n
     * @return int整型
     */
    bool isValid(int row, vector<int>& pos, int col){
        for(int i = 0; i < row; i++){
            if(row == i || col == pos[i] || abs(row - i) == abs(col - pos[i])) // 45度所以利用等腰三角形的性质判断
                return false;
        }
        return true;
    }
    
    void recursion(int row,int& count,vector<int>& pos, int& n){
        if(row == n){
            count++;
            return;
        }
        
        for(int i = 0; i < n; i++){
            if(isValid(row, pos, i)){
                pos[row] = i;
                recursion(row+1 , count, pos, n);
            }
        }
    }
    
    
    int Nqueen(int n) {
        // write code here
        vector<int>pos(n, -1);
        int count = 0;
        recursion(0, count, pos, n);
        return count;
    }
};
```

**括号生成**

**思路分析：**分析题目，我们可以得到，题目的要求为当输入n对括号后，输出所有由n对括号组成的合法组合，这就意味着，当“（”出现的时候，后序必须要有与之配对的“）”存在，首先我们可以设定一个容器对象vector用于存储最终的结果值，设定一个string类型的变量用于存储括号的对数，设定两个变量值分别为i和j，用于监督此刻需要的“（”或者“）”。

其中i和j的值主要分为五种情况，我们一一进行分析（首先定义i和j的值均为n）：

第一种：当n为0时，也就是i = j = 0，这时，说明不需要分配括号，直接返回字符串类型即可。

第二种：当i = 0，j > 0时，我们需要添加一个“）”类型，随即将j的值减一，然后进行递归判断。

第三种：当i > 0，j = 0时，我们需要添加一个“（”类型，随即将i的值减一，然后进行递归判断。

第四种：当i的值小于j的值时，我们也可以先添加“（”，令i的值减一后，递归（执行完之后进行回溯判断再次递归），再添加“）”，y - 1后再次进行递归操作。

第五种：当i的值大于等于j时，进行“（”的添加。

```c++
class Solution {
public:
    /**
     * 
     * @param n int整型 
     * @return string字符串vector
     */
    void recursion(vector<string>& res, int& n, string temp, int left, int right){
        if(left == n && right == n){
            res.push_back(temp);
            return;
        }
        
        if(left < n){
            recursion(res, n, temp+"(", left+1, right);
        }
        
        if(right < left && right < n){
            recursion(res, n, temp+")", left, right+1);
        }
    }
    
    vector<string> generateParenthesis(int n) {
        // write code here
        vector<string>res;
        string temp;
        recursion(res, n, temp, 0, 0);
        return res;
    }
};
```

**矩阵最长递增路径**

回溯+动态规划。

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 递增路径的最大长度
     * @param matrix int整型vector<vector<>> 描述矩阵的每个数
     * @return int整型
     */
    
    int recursion(vector<vector<int>>&dp, vector<vector<int>>&matrix, int i, int j){
        if(dp[i][j]){//我们只要遍历过这个节点，那么我们就可以得到这个节点到最大的节点的最优距离是多少
            return dp[i][j];
        }
        dp[i][j]++;
        for(int k = 0; k < 4; k++){
            int row = i + dir[k][0];
            int col = j + dir[k][1];
            
            if(row >= 0 && row < m && col >= 0 && col < n && 
               matrix[row][col] > matrix[i][j]){
                dp[i][j] = max(dp[i][j], recursion(dp, matrix, row, col)+1);
            }
        }
        
        return dp[i][j];
    }
    int solve(vector<vector<int> >& matrix) {
        // write code here
        if(matrix.size() == 0 || matrix[0].size() == 0)return 0;
        
         m = matrix.size();
         n = matrix[0].size();
        vector<vector<int>>dp(m, vector<int>(n));
        int res = 0;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++){
                res = max(res, recursion(dp, matrix,  i,  j));
            }
        return res;
    }
private:
    int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    int n;
    int m;
};
```





##### 动态规划

**斐波那契额数列**

将记忆化搜索的递归部分修改为迭代。
1、题解一分析出本题f(n)可以拆分出重叠子问题f(n-1)、f(n-2);
2、f(n)=f(n-1)+f(n-2)是动态规划的状态转移方程；
3、f(0)=0,f(1)=1是动态规划的初始状态；
4、dp为一维数组，其中dp[i]的值代表斐波拉契数列第n项的值；

**复杂度分析：**
时间复杂度：*O(n)*
空间复杂度：*O(n)*,建立一个保存状态的数组;

```c++
class Solution {
public:
    int Fibonacci(int n) {
        dp = new int[n+1]();
        return function(n);
    }
    
    int function(int n){
        if(n == 1 || n == 2){
            return 1;
        }
        
        if(dp[n]){
            return dp[n];
        }
        dp[n] = function(n - 1) + function(n - 2);
        return dp[n];
    }
private:
    int *dp;
};
```



**跳台阶**

**动态规划**
将记忆化搜索的递归部分修改为迭代。
1、题解一分析出本题f(n)可以拆分出重叠子问题f(n-1)、f(n-2);
2、f(n)=f(n-1)+f(n-2)是动态规划的状态转移方程；
3、f(0)=1,f(1)=1是动态规划的初始状态；
4、dp为一维数组，其中dp[i]的值代表青蛙跳第n个台阶的方法数；

**复杂度分析：**
时间复杂度：*O(n)*
空间复杂度：*O(n)*,建立一个保存状态的数组;

```c++
class Solution {
public:
    int jumpFloor(int number) {
        dp = new int[number+1]();    
        return recursion(number);
    }
    
    int recursion(int num){
        if(num == 1 || num == 2)return num;
        
        if(dp[num]){
            return dp[num];
        }
        
        dp[num] = recursion(num - 1) + recursion(num - 2);
        return dp[num];
    }
private:
    int *dp;
};
```



**最小花费爬楼梯**

动态规划

分析：

这个题的本质其实和跳楼梯差不多的，只不过加了代价而已，那么假设跳n个台阶的代价为f(n)那么：
如果第n个台阶是由跳1阶而来的，那么代价就是f(n-1)+a[n]
如果第n个台阶是由跳2阶而来的，那么代价就是f(n-2)+a[n]
由此可得：f(n) = min(f(n-1), f(n-2))+a[i]
当n=0时，f(0) = a[0]
当n=1时，f(1) = a[1]

tips：

(1). 这个题的题意不是很明确，其实根据数据测出是应该跳出n阶，即计算的是dp[n+1]。

(2). 输入还是以字符串输入的比较恶心，还是按照之前的方法使用stringstream处理，也很方便的。

**算法实现：**
(1). 输入一个字符串，然后根据stringstream处理，得到一个长度为n的整型数组。
(2). 定义dp数组，其中dp[i]表示跳到第i个台阶的最小代价，初始化dp的值，即dp[0] = a[0], dp[1] = a[1];

(3). 按照之前的状态转移方程进行遍历计算。

(4). 输出dp[n]即可，因为下标是从0开始的。

.复杂度分析：

时间复杂度：O(n) 
空间复杂度：O(n)

```c++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param cost int整型vector 
     * @return int整型
     */
    int minCostClimbingStairs(vector<int>& cost) {
        // write code here
        vector<int>dp(cost.size() + 1, 0);
        
        for(int i = 2; i <= cost.size(); i++){
            dp[i] = min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);
        }
        
        return dp[cost.size()];
    }
};
```

最长公共子序列（二）

```
 ``//注意dp的长度问题，是s1.length+1与s2.length+1，为什么要加1呢，虽然s1,s2的索引范围为[0,row-1],[0,column-1]
    ``//但是要多记录一种情况即s1和s2为空字符串的情况，使用dp[i][0]与dp[0][j]来记录，那么肯定为0，dp[0][j]与dp[i][0]使用默认的0就行。
    ``//所以dp的行数范围为[0,row],列数范围为[0,column]，比s1和s2的长度多1，即dp[i,j]表示s1长度为i-1，s2长度为j-1的最长公共子序列的长度,.
//三种情况


//    插入的思想：
      若dp[8][9] = 5，且S1[7] != S2[8]，所以倒推回去，dp[8][9]的值来源于dp[8][8]与dp[7][9]的值的最大值。根据情况让row-1或者column-1。
      若dp[8][9] = 5, 且S1[7] = S2[8], 所以倒推回去，dp[8][9]的值来源于 dp[7][8]。row-1且column-1。
      有种特殊情况：
      若dp[8][9] = 5,且S1[7] != S2[8] ，且dp[8][8] = c[7][9] 这种存在分支的情况，这里请都选择一个方向（之后遇到这样的情况，也选择相同的方向）。
      最长子序列的解不是唯一的，在每次遇到dp[8][9] = 5,且S1[7] != S2[8] ，且dp[8][8] = c[7][9]这种情况时，选择不同的方向就会造成不同的解。
      牛客的示例中是向左走，参考的算法的网站中是向上走的~怎么走都可以。
```

```c++
class Solution {
public:
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    string LCS(string s1, string s2) {
        // write code here
        int m = s1.length();
        int n = s2.length();
        vector<vector<int>>dp(m+1,vector<int>(n+1, 0));
        
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++){
                if(s1[i] == s2[j]){
                    dp[i+1][j+1] = 1 + dp[i][j];
                }else{
                    dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);
                }
            }
        
        if(dp[m][n] == 0)return string("-1");
        
        int lcsLen = dp[m][n];
        vector<char>lcs(lcsLen);
        int cur = lcsLen-1;
        while(true){
            if(s1[m-1] == s2[n-1]){
                lcs[cur--] = s1[m-1];
                if(cur < 0)return string(lcs.begin(), lcs.end());
                m--;
                n--;
            }else{
                if(dp[m-1][n] > dp[m][n-1]){
                    m--;//往上走
                }else{
                    n--;//往左走
                }
            }
        }
    }
};
```

**最长公共子串**

注意这题求的是最长公共子串，不是最长公共子序列，子序列可以是不连续的，但子串一定是连续的。

定义**dp[i][j]表示字符串str1中第i个字符和str2种第j个字符为最后一个元素所构成的最长公共子串**。如果要求dp[i][j]，也就是str1的第i个字符和str2的第j个字符为最后一个元素所构成的最长公共子串，我们首先需要判断这两个字符是否相等。

- 如果不相等，那么他们就不能构成公共子串，也就是
  **dp[i][j]=0;**
- 如果相等，我们还需要计算前面相等字符的个数，其实就是dp[i-1][j-1]，所以
  **dp[i][j]=dp[i-1][j-1]+1**;

动态规划代码优化

上面我们使用的是二维数组，我们发现计算当前位置的时候之和左上角的值有关，所以我们可以把二维数组变为一维数组，注意第2个for循环要进行倒叙，因为后面的值要依赖前面的值，如果不倒叙，前面的值会被覆盖，导致结果错误

```c++
class Solution {
public:
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    string LCS(string str1, string str2) {
        // write code here
        int maxLength = 0;
        int maxLengthIndex = 0;
        int len1 = str1.length();
        int len2 = str2.length();
        vector<int>dp(len2+1);
        
        for(int i = 0; i < len1; i++)
            for(int j = len2-1; j >= 0; j--){
                if(str1[i] == str2[j]){
                    dp[j+1] = 1 + dp[j];
                    
                    if(dp[j+1] > maxLength){
                        maxLength = dp[j+1];
                        maxLengthIndex = i;
                    }
                }else{
                        dp[j+1] = 0;
                }
        }
        return str1.substr(maxLengthIndex - maxLength + 1, maxLength);
    }
};
```

**不同路径的数目**

（动态规划）：

假设机器人站在点(i，j)处，其可以从(i-1，j)向下移动一行走到，也可以从向右移动一步走到。因此到达位置(i，j)出路径的数目等于到达位置(i-1，j)的路径数目 与达到(i，j-1)的路径数目之和。我们假设dp[i,j]表示到达点(i，j)的路径数目，那么dp[i,j] = dp[i-1,j]+dp[i,j-1]。我们新建一个二维表格dp，计算dp里面每一个值，最后返回目标位置的dp即可。

初始化，第一行和第一列的dp值全部为1，这些位置可以确定只有一条路径。表格的其他位置，根据转移方程，进行填充即可。
如下图，站在红叉的位置，根据规则，其只能从其左边和上面走到，那么到达红叉的走法就是前两步骤的和。

```c++
class Solution {
public:
    /**
     * 
     * @param m int整型 
     * @param n int整型 
     * @return int整型
     */
    int uniquePaths(int m, int n) {
        // write code here
        vector<vector<int>>dp(m+1,vector<int>(n+1));
        dp[1][1] = 1;
        for(int i = 1; i <= m; i++)
            for(int j = 1; j <=n; j++){
                if(i == 1 && j == 1)continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; //路径数等于左方+上方
            }
        return dp[m][n];
    }
};
```

##### 模拟

**旋转数组**

该方法基于如下的事实：将数组的元素向右移动 k 次后，尾部 m mod n 个元素会移动至数组头部，其余元素向后移动 m mod n 个位置。
该方法为数组的翻转：翻转算法参考 反转链表中的双指针方法 https://blog.nowcoder.net/n/d259b250747b4085bc7975f102d248c4

1、可以先将所有元素翻转，这样尾部的 m mod n 个元素就被移至数组头部，

2、然后再翻转 [0,m mod n−1] 区间的元素

3、 最后翻转[m mod n,n−1] 区间的元素即能得到最后的答案。

```c++
class Solution {
public:
    /**
     * 旋转数组
     * @param n int整型 数组长度
     * @param m int整型 右移距离
     * @param a int整型vector 给定数组
     * @return int整型vector
     */
    vector<int> solve(int n, int m, vector<int>& a) {
        // write code here
        m = m%n;
        reverse(a.begin(), a.end());
        reverse(a.begin(), a.begin()+m);
        reverse(a.begin()+m, a.end());
        
        return a;
    }
};
```

**螺旋矩阵**

进行旋转打印，那么方法二的话我们还可以一圈一圈打印，其实跟方法一的代码很类似，但是是两种不同的想法，在于你对解决方式的理解不同。
其实就是根据下面的圈，根据定义的两个点，左上角和右下角去进行圈的遍历，两个点的x，y坐标其实跟方法一的left，right，top，bottom是起到一样作用的，只是这是另外一种思想。

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int> > &matrix) {
        int m = matrix.size();
        if(m == 0)return{};
        
        int n = matrix[0].size();
        if(n == 0)return{};
        int up = -1;
        int down = m;
        int left = -1;
        int right = n;
        vector<int>res;
        int sum = m * n;
        while(res.size() < sum){
            int up1 = up+1;
            if(up1 < down)
                for(int i = left + 1; i < right; i++){
                    res.push_back(matrix[up1][i]);
                }
            up++;
            
            int right1 = right-1;
            if(right1 > left)
                for(int i = up + 1; i < down; i++){
                    res.push_back(matrix[i][right1]);
                }
            right--;
            
            int down1 = down - 1;
            if(down1 > up)
                for(int i = right-1; i > left; i--){
                    res.push_back(matrix[down1][i]);
                }
            down--;
            
            int left1 = left + 1;
            if(left1 < right)
                for(int i = down - 1; i > up; i--){
                    res.push_back(matrix[i][left1]);
                }
            left++;
        }
        return res;
    }
};
```

